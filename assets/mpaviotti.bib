@inproceedings{DBLP:conf/esop/YangPWBS22,
  author    = {Zhixuan Yang and
               Marco Paviotti and
               Nicolas Wu and
               Birthe van den Berg and
               Tom Schrijvers},
  editor    = {Ilya Sergey},
  title     = {Structured Handling of Scoped Effects},
  booktitle = {31st European Symposium on Programming,
               {ESOP} },
  series    = {Lecture Notes in Computer Science},
  volume    = {13240},
  pages     = {462--491},
  publisher = {Springer},
  year      = {2022},
  url       = {https://doi.org/10.1007/978-3-030-99336-8\_17},
  doi       = {10.1007/978-3-030-99336-8\_17},
  timestamp = {Fri, 29 Apr 2022 14:50:41 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/YangPWBS22.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{DBLP:conf/esop/PaviottiCPWOB20,
  author    = {Marco Paviotti and
               Simon Cooksey and
               Anouk Paradis and
               Daniel Wright and
               Scott Owens and
               Mark Batty},
  editor    = {Peter M{\"{u}}ller},
  title     = {Modular Relaxed Dependencies in Weak Memory Concurrency},
  booktitle = {29th European Symposium on Programming, {ESOP}},
  series    = {Lecture Notes in Computer Science},
  volume    = {12075},
  pages     = {599--625},
  publisher = {Springer},
  year      = {2020},
  url       = {https://link.springer.com/content/pdf/10.1007/978-3-030-44914-8_22.pdf},
  doi       = {10.1007/978-3-030-44914-8\_22},
  timestamp = {Fri, 14 May 2021 08:34:21 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/PaviottiCPWOB20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {We present a denotational semantics for weak memory concurrency that avoids thin-air reads, provides data-race free programs with sequentially consistent semantics (DRF-SC), and supports a com- positional refinement relation for validating optimisations. Our semantics identifies false program dependencies that might be removed by compiler optimisation, and leaves in place just the dependencies necessary to rule out thin-air reads. We show that our dependency calculation can be used to rule out thin-air reads in any axiomatic concurrency model, in particular C++. We present a tool that automatically evaluates litmus tests, show that we can augment C++ to fix the thin-air problem, and we prove that our augmentation is compatible with the previously used compilation mappings over key processor architectures. We argue that our dependency calculation offers a practical route to fixing the long-standing problem of thin-air reads in the C++ specification.}
  }

@article{DBLP:journals/mscs/MogelbergP19,
  author    = {Rasmus Ejlers Møgelberg and
               Marco Paviotti},
  title     = {Denotational semantics of recursive types in synthetic guarded domain
               theory},
  journal   = {Mathematical Structures in Computer Science, {MSCS}},
  volume    = {29},
  number    = {3},
  pages     = {465--510},
  year      = {2019},
  publisher = {Cambridge University Press},
  url       = {/assets/papers/mscs19.pdf},
  doi       = {10.1017/S0960129518000087},
  timestamp = {Wed, 01 Apr 2020 08:48:51 +0200},
  biburl    = {https://dblp.org/rec/journals/mscs/MogelbergP19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {Just like any other branch of mathematics, denotational semantics of programming languages should be formalised in type theory, but adapting traditional domain theoretic semantics, as originally formulated in classical set theory to type theory has proven challenging. This paper is part of a project on formulating denotational semantics in type theories with guarded recursion. This should have the benefit of not only giving simpler semantics and proofs of properties such as adequacy, but also hopefully in the future to scale to languages with advanced features, such as general references, outside the reach of traditional domain theoretic techniques. Working in Guarded Dependent Type Theory (GDTT), we develop denotational semantics for FPC, the simply typed lambda calculus extended with recursive types, modelling the recursive types of FPC using the guarded recursive types of GDTT. We prove soundness and computational adequacy of the model in GDTT using a logical relation between syntax and semantics constructed also using guarded recursive types. The denotational semantics is intensional in the sense that it counts the number of unfold-fold reductions needed to compute the value of a term, but we construct a relation relating the denotations of extensionally equal terms, i.e., pairs of terms that compute the same value in a different number of steps. Finally we show how the denotational semantics of terms can be executed inside type theory and prove that executing the denotation of a boolean term computes the same value as the operational semantics of FPC.}
}

@article{DBLP:journals/jlp/PaviottiB18,
  author    = {Marco Paviotti and
               Jesper Bengtson},
  title     = {Formally verifying exceptions for low-level code with separation logic},
  journal   = {Journal of Logical and Algebraic Methods in Programming, {JLAMP}},
  volume    = {94},
  publisher = {Elsevier},
  pages     = {1--14},
  year      = {2018},
  url       = {/assets/papers/jlamp17.pdf},
  doi       = {10.1016/j.jlamp.2017.09.004},
  timestamp = {Sat, 22 Feb 2020 19:18:11 +0100},
  biburl    = {https://dblp.org/rec/journals/jlp/PaviottiB18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {Exceptions in low-level architectures are implemented as synchronous interrupts: upon 
  the execution of a faulty instruction the processor jumps to a piece of code that handles the error. 
  Previous work has shown that assembly programs can be written, verified and run using higher-order 
  separation logic [14]. However, execution of faulty instructions is then specified as either being 
  undefined or terminating with an error. In this paper, we study synchronous interrupts and show 
  their usefulness by implementing a memory allocator. This shows that it is indeed possible to 
  write positive specifications of programs that fault. All of our results are mechanised in the 
  interactive proof assistant Coq.}
}


@phdthesis{phdthesis,
  author       = {Marco Paviotti}, 
  title        = {Denotational semantics in Synthetic Guarded Domain Theory},
  booktitle     = {Ph.D. thesis},
  publisher       = {IT University of Copenhagen, Denmark},
  year         = 2016,
  url          = {/assets/papers/paviotti-phdthesis.pdf},
  abstract = {
In functional programming, features such as recursion, recursive types and general references are central. To define semantics of this kind of lan- guages one needs to come up with certain definitions which may be non- trivial to show well-defined. This is because they are circular. Domain theory has been used to solve this kind of problems for specific languages, unfortunately, this technique does not scale for more featureful languages, which prevented it from being widely used.
Step-indexing is a more general technique that has been used to break circularity of definitions. The idea is to tweak the definition by adding a well- founded structure that gives a handle for recursion. Guarded dependent Type Theory (gDTT) is a type theory which implements step-indexing via a unary modality used to guard recursive definitions. Every circular definition is well-defined as long as the recursive variable is guarded.
In this thesis we show that gDTT is a natural setting to give denotational semantics of typed functional programming languages with recursion and recursive types. We formulate operational semantics and denotational semantics and prove computational adequacy entirely inside the type theory. Furthermore, our interpretation is synthetic: types are interpreted as types in the type theory and programs as type-theoretical terms. Moreover, work- ing directly in gDTT has advantages compared with existing set-theoretic models.
Finally, this work builds the foundations for doing denotational seman- tics of languages with much more challenging features, for example, of general references for which denotational techniques were previously be- yond reach.}
}

@inproceedings{DBLP:conf/lics/MogelbergP16,
  author    = {Rasmus Ejlers Møgelberg and
               Marco Paviotti},
  editor    = {Martin Grohe and
               Eric Koskinen and
               Natarajan Shankar},
  title     = {Denotational semantics of recursive types in synthetic guarded domain
               theory},
  booktitle = {Proceedings of the 31st Annual {ACM/IEEE} Symposium on Logic in Computer
               Science, {LICS}},
  pages     = {317--326},
  publisher = {{ACM}},
  year      = {2016},
  url       = {/assets/papers/lics16.pdf},
  doi       = {10.1145/2933575.2934516},
  timestamp = {Wed, 11 Aug 2021 11:51:25 +0200},
  biburl    = {https://dblp.org/rec/conf/lics/MogelbergP16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract  = {Guarded recursion is a form of recursion where recursive calls are guarded by delay modalities. Previous work has shown how guarded recursion is useful for reasoning operationally about pro- gramming languages with advanced features including general ref- erences, recursive types, countable non-determinism and concur- rency.
Guarded recursion also offers a way of adding recursion to type theory while maintaining logical consistency. In previous work we initiated a programme of denotational semantics in type theory us- ing guarded recursion, by constructing a computationally adequate model of the language PCF (simply typed lambda calculus with fixed points). This model was intensional in that it could distinguish between computations computing the same result using a different number of fixed point unfoldings.
In this work we show how also programming languages with recursive types can be given denotational semantics in type theory with guarded recursion. More precisely, we give a computation- ally adequate denotational semantics to the language FPC (simply typed lambda calculus extended with recursive types), modelling recursive types using guarded recursive types. The model is inten- sional in the same way as was the case in previous work, but we show how to recover extensionality using a logical relation.
All constructions and reasoning in this paper, including proofs of theorems such as soundness and adequacy, are by (informal) reasoning in type theory, often using guarded recursion.}
}

@inproceedings{DBLP:journals/entcs/PaviottiMB15,
  author    = {Marco Paviotti and
               Rasmus Ejlers Møgelberg and
               Lars Birkedal},
  editor    = {Dan R. Ghica},
  title     = {A Model of {PCF} in Guarded Type Theory},
  booktitle = {The 31st Conference on the Mathematical Foundations of Programming
               Semantics, {MFPS}},
  series    = {Electronic Notes in Theoretical Computer Science},
  volume    = {319},
  pages     = {333--349},
  publisher = {Elsevier},
  year      = {2015},
  url       = {/assets/papers/mfps15.pdf},
  doi       = {10.1016/j.entcs.2015.12.020},
  timestamp = {Mon, 08 Feb 2021 13:26:28 +0100},
  biburl    = {https://dblp.org/rec/journals/entcs/PaviottiMB15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}, 
  abstract = {Guarded recursion is a form of recursion where recursive calls are guarded by delay modalities. Previous work has shown how guarded recursion is useful for constructing logics for reasoning about programming languages with advanced features, as well as for constructing and reasoning about elements of coinductive types. In this paper we investigate how type theory with guarded recursion can be used as a metalanguage for denotational semantics useful both for constructing models and for proving properties of these. We do this by constructing a fairly intensional model of PCF and proving it computationally adequate. The model construction is related to Escardo’s metric model for PCF, but here everything is carried out entirely in type theory with guarded recursion, including the formulation of the operational semantics, the model construction and the proof of adequacy.}
}


@inproceedings{MiculanP13,
  author    = {Marino Miculan and
               Marco Paviotti},
  title     = {Extraction of certified programs with effects from proofs with monadic types in Coq},
  booktitle = {Unpublished Manuscript},
  year      = {2013},
  publisher = {Draft},
  url       = {/assets/papers/statesynt13.pdf},
  abstract = {We present a methodology for the extraction of certified pro- grams with effects, using the Coq proof assistant and monadic types. First, we define in the Calculus of Inductive Constructions an abstract global store monad, by suitably adapting Plotkin-Power’s sound and com- plete axiomatization. This monad gives raise to monadic types which can be used for the specifications of imperative programs in Coq. From the (constructive) proofs of these specifications, using Coq’s Extraction fa- cility we can extract programs in a computational metalanguage CompML, which is basically the functional fragment of ML extended with the monad’s operators.
In order to obtain executable code, we define a back-end compiler from CompML to the target language, i.e. ML in our case. A program in CompML is translated to executable ML code by replacing monadic con- structors with the corresponding SML operations. The back-end compiler is proved to be correct, by formally proving that it respects the axiomati- zation of the global store monad. Hence, the code it produces is certified. This methodology can be ported to other computational aspects, by suitably adapting the monadic type theory and the back-end compiler, as long as the target language can be given a formal semantics in Coq.}
}



@inproceedings{DBLP:conf/itp/MiculanP12,
  author    = {Marino Miculan and
               Marco Paviotti},
  editor    = {Lennart Beringer and
               Amy P. Felty},
  title     = {Synthesis of Distributed Mobile Programs Using Monadic Types in Coq},
  booktitle = {Interactive Theorem Proving - Third International Conference, {ITP}},
  series    = {Lecture Notes in Computer Science},
  volume    = {7406},
  pages     = {183--200},
  publisher = {Springer},
  year      = {2012},
  url       = {/assets/papers/itp12.pdf},
  doi       = {10.1007/978-3-642-32347-8\_13},
  timestamp = {Tue, 29 Dec 2020 18:37:35 +0100},
  biburl    = {https://dblp.org/rec/conf/itp/MiculanP12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {We present a methodology for the automatic synthesis of certified, distributed, mobile programs with side effects in Erlang, using the Coq proof assistant.
First, we define monadic types in the Calculus of Inductive Constructions, using a lax monad covering the distributed computational aspects. These types can be used for the specifications of programs in Coq. From the (constructive) proofs of these specifications we can extract Haskell code, which is decorated with symbols representing distributed nodes and specific operations for distributed computations. These syntactic anno- tations are exploited by a back-end compiler to produce actual mobile code for a suitable runtime environment (Erlang, in our case).
Then, we introduce an object type theory for distributed computations, which can be used as a front-end programming language. These types and terms are translate to CIC extended with monadic types; this allows us to prove the soundess of the object type theory, and to obtain an implementation of the language via Coq’s extraction features.
This methodology can be ported to other computational aspects, by suitably adapting the monadic type theory and the back-end compiler.}
}


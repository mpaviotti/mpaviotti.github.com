@inproceedings{esop22,
  author    = {Zhixuan Yang and Marco Paviotti and Nicolas Wu and Birthe van den Berg and Tom Schrijvers},
  title     = {Structured Handling of Scoped Effects},
  url = {To appear},
  published = {To appear},
  booktitle = {European Symposium on Programming, {ESOP} 2022},
  series    = {Lecture Notes in Computer Science},
  year      = {2022},
  abstract = {Algebraic effects offer a versatile framework that covers a wide variety of effects. However, the family of operations that delimit scopes are not algebraic and are usually modelled as handlers, thus pre- venting them from being used freely in conjunction with algebraic oper- ations. Although proposals for scoped operations exist, they are either ad-hoc and unprincipled, or too inconvenient for practical programming. This paper provides the best of both worlds: a theoretically-founded model of scoped effects that is convenient for implementation and rea- soning. Our new model is based on an adjunction between a locally finitely presentable category and a category of functorial algebras. Using comparison functors between adjunctions, we show that our new model, an existing indexed model, and a third approach that simulates scoped operations in terms of algebraic ones have equal expressivity for han- dling scoped operations. We consider our new model to be the sweet spot between ease of implementation and structuredness. Additionally, our approach automatically induces fusion laws of handlers of scoped effects, which are useful for reasoning and optimisation.}
  }

@inproceedings{DBLP:conf/esop/PaviottiCPWOB20,
  author    = {Marco Paviotti and
               Simon Cooksey and
               Anouk Paradis and
               Daniel Wright and
               Scott Owens and
               Mark Batty},
  editor    = {Peter M{\"{u}}ller},
  title     = {Modular Relaxed Dependencies in Weak Memory Concurrency},
  booktitle = {Programming Languages and Systems - 29th European Symposium on Programming,
               {ESOP} 2020, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2020, Dublin, Ireland, April 25-30,
               2020, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {12075},
  pages     = {599--625},
  publisher = {Springer},
  year      = {2020},
  url       = {https://doi.org/10.1007/978-3-030-44914-8\_22},
  doi       = {10.1007/978-3-030-44914-8\_22},
  timestamp = {Fri, 14 May 2021 08:34:21 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/PaviottiCPWOB20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {We present a denotational semantics for weak memory concurrency that avoids thin-air reads, provides data-race free programs with sequentially consistent semantics (DRF-SC), and supports a com- positional refinement relation for validating optimisations. Our semantics identifies false program dependencies that might be removed by compiler optimisation, and leaves in place just the dependencies necessary to rule out thin-air reads. We show that our dependency calculation can be used to rule out thin-air reads in any axiomatic concurrency model, in particular C++. We present a tool that automatically evaluates litmus tests, show that we can augment C++ to fix the thin-air problem, and we prove that our augmentation is compatible with the previously used compilation mappings over key processor architectures. We argue that our dependency calculation offers a practical route to fixing the long-standing problem of thin-air reads in the C++ specification.}
  }

@article{DBLP:journals/mscs/MogelbergP19,
  author    = {Rasmus Ejlers M{\o}gelberg and
               Marco Paviotti},
  title     = {Denotational semantics of recursive types in synthetic guarded domain
               theory},
  journal   = {Math. Struct. Comput. Sci.},
  volume    = {29},
  number    = {3},
  pages     = {465--510},
  year      = {2019},
  url       = {https://doi.org/10.1017/S0960129518000087},
  doi       = {10.1017/S0960129518000087},
  timestamp = {Wed, 01 Apr 2020 08:48:51 +0200},
  biburl    = {https://dblp.org/rec/journals/mscs/MogelbergP19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {Just like any other branch of mathematics, denotational semantics of programming languages should be formalised in type theory, but adapting traditional domain theoretic semantics, as originally formulated in classical set theory to type theory has proven challenging. This paper is part of a project on formulating denotational semantics in type theories with guarded recursion. This should have the benefit of not only giving simpler semantics and proofs of properties such as adequacy, but also hopefully in the future to scale to languages with advanced features, such as general references, outside the reach of traditional domain theoretic techniques. Working in Guarded Dependent Type Theory (GDTT), we develop denotational semantics for FPC, the simply typed lambda calculus extended with recursive types, modelling the recursive types of FPC using the guarded recursive types of GDTT. We prove soundness and computational adequacy of the model in GDTT using a logical relation between syntax and semantics constructed also using guarded recursive types. The denotational semantics is intensional in the sense that it counts the number of unfold-fold reductions needed to compute the value of a term, but we construct a relation relating the denotations of extensionally equal terms, i.e., pairs of terms that compute the same value in a different number of steps. Finally we show how the denotational semantics of terms can be executed inside type theory and prove that executing the denotation of a boolean term computes the same value as the operational semantics of FPC.}
}

@article{DBLP:journals/jlp/PaviottiB18,
  author    = {Marco Paviotti and
               Jesper Bengtson},
  title     = {Formally verifying exceptions for low-level code with separation logic},
  journal   = {J. Log. Algebraic Methods Program.},
  volume    = {94},
  pages     = {1--14},
  year      = {2018},
  url       = {https://doi.org/10.1016/j.jlamp.2017.09.004},
  doi       = {10.1016/j.jlamp.2017.09.004},
  timestamp = {Sat, 22 Feb 2020 19:18:11 +0100},
  biburl    = {https://dblp.org/rec/journals/jlp/PaviottiB18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {Exceptions in low-level architectures are implemented as synchronous interrupts: upon the execution of a faulty instruction the processor jumps to a piece of code that handles the error. Previous work has shown that assembly programs can be written, verified and run using higher-order separation logic [14]. However, execution of faulty instructions is then specified as either being undefined or terminating with an error. In this paper, we study synchronous interrupts and show their usefulness by implementing a memory allocator. This shows that it is indeed possible to write positive specifications of programs that fault. All of our results are mechanised in the interactive proof assistant Coq.}
}

@inproceedings{DBLP:conf/lics/MogelbergP16,
  author    = {Rasmus Ejlers M{\o}gelberg and
               Marco Paviotti},
  editor    = {Martin Grohe and
               Eric Koskinen and
               Natarajan Shankar},
  title     = {Denotational semantics of recursive types in synthetic guarded domain
               theory},
  booktitle = {Proceedings of the 31st Annual {ACM/IEEE} Symposium on Logic in Computer
               Science, {LICS} '16, New York, NY, USA, July 5-8, 2016},
  pages     = {317--326},
  publisher = {{ACM}},
  year      = {2016},
  url       = {https://doi.org/10.1145/2933575.2934516},
  doi       = {10.1145/2933575.2934516},
  timestamp = {Wed, 11 Aug 2021 11:51:25 +0200},
  biburl    = {https://dblp.org/rec/conf/lics/MogelbergP16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract  = {Guarded recursion is a form of recursion where recursive calls are guarded by delay modalities. Previous work has shown how guarded recursion is useful for reasoning operationally about pro- gramming languages with advanced features including general ref- erences, recursive types, countable non-determinism and concur- rency.
Guarded recursion also offers a way of adding recursion to type theory while maintaining logical consistency. In previous work we initiated a programme of denotational semantics in type theory us- ing guarded recursion, by constructing a computationally adequate model of the language PCF (simply typed lambda calculus with fixed points). This model was intensional in that it could distinguish between computations computing the same result using a different number of fixed point unfoldings.
In this work we show how also programming languages with recursive types can be given denotational semantics in type theory with guarded recursion. More precisely, we give a computation- ally adequate denotational semantics to the language FPC (simply typed lambda calculus extended with recursive types), modelling recursive types using guarded recursive types. The model is inten- sional in the same way as was the case in previous work, but we show how to recover extensionality using a logical relation.
All constructions and reasoning in this paper, including proofs of theorems such as soundness and adequacy, are by (informal) reasoning in type theory, often using guarded recursion.}
}

@inproceedings{DBLP:journals/entcs/PaviottiMB15,
  author    = {Marco Paviotti and
               Rasmus Ejlers M{\o}gelberg and
               Lars Birkedal},
  editor    = {Dan R. Ghica},
  title     = {A Model of {PCF} in Guarded Type Theory},
  booktitle = {The 31st Conference on the Mathematical Foundations of Programming
               Semantics, {MFPS} 2015, Nijmegen, The Netherlands, June 22-25, 2015},
  series    = {Electronic Notes in Theoretical Computer Science},
  volume    = {319},
  pages     = {333--349},
  publisher = {Elsevier},
  year      = {2015},
  url       = {https://doi.org/10.1016/j.entcs.2015.12.020},
  doi       = {10.1016/j.entcs.2015.12.020},
  timestamp = {Mon, 08 Feb 2021 13:26:28 +0100},
  biburl    = {https://dblp.org/rec/journals/entcs/PaviottiMB15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}, 
  abstract = {Guarded recursion is a form of recursion where recursive calls are guarded by delay modalities. Previous work has shown how guarded recursion is useful for constructing logics for reasoning about programming languages with advanced features, as well as for constructing and reasoning about elements of coinductive types. In this paper we investigate how type theory with guarded recursion can be used as a metalanguage for denotational semantics useful both for constructing models and for proving properties of these. We do this by constructing a fairly intensional model of PCF and proving it computationally adequate. The model construction is related to Escardo’s metric model for PCF, but here everything is carried out entirely in type theory with guarded recursion, including the formulation of the operational semantics, the model construction and the proof of adequacy.}
}

@inproceedings{DBLP:conf/itp/MiculanP12,
  author    = {Marino Miculan and
               Marco Paviotti},
  editor    = {Lennart Beringer and
               Amy P. Felty},
  title     = {Synthesis of Distributed Mobile Programs Using Monadic Types in Coq},
  booktitle = {Interactive Theorem Proving - Third International Conference, {ITP}
               2012, Princeton, NJ, USA, August 13-15, 2012. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {7406},
  pages     = {183--200},
  publisher = {Springer},
  year      = {2012},
  url       = {https://doi.org/10.1007/978-3-642-32347-8\_13},
  doi       = {10.1007/978-3-642-32347-8\_13},
  timestamp = {Tue, 29 Dec 2020 18:37:35 +0100},
  biburl    = {https://dblp.org/rec/conf/itp/MiculanP12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract = {We present a methodology for the automatic synthesis of certified, distributed, mobile programs with side effects in Erlang, using the Coq proof assistant.
First, we define monadic types in the Calculus of Inductive Constructions, using a lax monad covering the distributed computational aspects. These types can be used for the specifications of programs in Coq. From the (constructive) proofs of these specifications we can extract Haskell code, which is decorated with symbols representing distributed nodes and specific operations for distributed computations. These syntactic anno- tations are exploited by a back-end compiler to produce actual mobile code for a suitable runtime environment (Erlang, in our case).
Then, we introduce an object type theory for distributed computations, which can be used as a front-end programming language. These types and terms are translate to CIC extended with monadic types; this allows us to prove the soundess of the object type theory, and to obtain an implementation of the language via Coq’s extraction features.
This methodology can be ported to other computational aspects, by suitably adapting the monadic type theory and the back-end compiler.}
}

